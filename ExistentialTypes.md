# Introduction #

In the general case without subtyping, type reconstruction remains decidable up to rank-2 polymorphism. This rank of polymorphism does not only support normal, universally-quantified “generic” functions, but functions with second-order universal quantification, which is considered equivalent to first-order _existential_ quantification. Existential types are best known as the type-theoretic encoding of _abstract data types_, which allow us to refer to certain data structures while “locking away” their internal representations. This kind of encapsulation corresponds well with the _interfaces_ provided in ordinary object-oriented languages such as Java.

# Details #

It has proven possible to add existential types to a normally first-order language while still maintaining a decidable, unification-based type inference algorithm[Laüfer1994]; at least one practical compiler implementing an extension to Caml on this basis has been written. An implementation for a systems language was provided in Cyclone, although Cyclone's existentials only work on boxed (pointer-sized) data types. Deca does not treat ⊤ as a real type (that is, ⊤ indicates a type-inference error and cannot be assigned to an expression or type variable) and therefore cannot promote an existential skolem-constructor to ⊤ to let it escape the body of an unpacking. Existential types thus integrate soundly and well with Deca's core type system as they did with Caml's, given the above restriction.

On the basis of this material, I am implementing existential types as a language feature of Deca.  Given the correctness of my research to date, both Deca's type system and Caml-Light's restrict System F in near-identical ways, except that Deca adds subtyping.

The Deca compiler tracks, at the creation of each existential package, the set of "closed-over" and existentially-packed data variables.  It then builds a tuple out of these and packs a pointer to this tuple as the existentially-quantified data member of the package/closure, accounting for any universal type quantifiers that have to appear to the left of the existential quantifier and all region/effect information the package must expose.  Only functions manipulating this pointer, rather than the unboxed existentially-typed data itself, can be packed into an existential package.  This restricts the possible existential packages to those manipulating boxed data, but for this cost, existential types integrate cleanly with systems programming: the LLVM type of every existentially-typed data member is the same.  This guarantees that the ABI of a function _before_ existential packaging remains identical to its ABI afterwards.

As is well-known in the research literature, existential types can be used to implement first-class modules and lexical closures, both of which Deca will support (subject to the boxing restriction).