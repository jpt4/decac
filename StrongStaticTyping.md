# Deca's type system #

Deca employs, at its core, a strong type system based restricting the lambda calculus System F-<:, as given by Pierce[Pierce2003-1]. The basic calculus was extended with sum types (complete with Pierce's rules for sum-type subtyping), restricted to require record invariance (because record covariance interferes with safe mutability of record fields), and restricted to let-polymorphism (rank-1, predicative polymorphism with the value restriction)[Pierce2003-2]. Pierce provides preservation and progress proofs for all these features (including their subtyping relations) and for basic System F-<:, so there exists a provably type-safe core calculus underlying Deca. This is essentially Hindley-Milner as it appears in ML, but with subtyping added on.

The primary addition in Deca has been a type-inference algorithm for such a system, as specified in the accompanying technical report[NEEDED](CITATION.md). Type variables are treated as ranges between an optional lower type bound and an optional upper type bound. Non-variable types are arranged into a lattice to find joins and meets of types. Type inequality constraints are evaluated similarly to how unification evaluates equality constraints, propagating type variables and restricting their bounds. In the end, every type variable is bounded on the lower end by the join of all types constrained to subtype it, and bounded on the upper end by the meet of all types it is constrained to subtype. This enables the inference of principally polymorphic, minimal types for Deca functions and variables.

# Controlled unsafety: the power for systems programming #

However, systems programming sometimes requires relaxing even the most useful safety guarantees. For example, kernel virtual memory subsystems on the x86 architecture[Intel2011](Intel2011.md) must often allocate memory at page boundaries, and then treat the newly-allocated page as an array of 32-bit pointers. This cannot be done via a language runtime's heap-allocation algorithms that don't respect page boundaries, since a true systems language cannot actually impose the use of a specific runtime library on its users. Deca thus provides an “escape hatch” for violating type-safety, when necessary, in the form of _bit-cast_ expressions. These accept an expression and reinterpret the physical memory occupied by the result as having an arbitrary given type, asserting that type to the type-inference system without constraining the type of its input at all. They are equivalent to C++'s **reinterpret\_cast**[ISO2003](ISO2003.md), though they operate on any data types rather than just pointers by allocating space for the resulting type and storing the source data into that space. Since cast expressions are typed as their result type, they integrate with the rest of the type system.

_cast\_expression_ ::= **cast** < _type\_form_ > ( _expression_ )