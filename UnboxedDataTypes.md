# Introduction #

All data types in Deca, other than variants, are compiled down to unboxed representations. Parametrically polymorphic functions are type-checked and generalized once, and then instantiated to a separate body of type-specialized code for each assignment of values to type parameters. The decac compiler therefore performs _type specialization_ and _type erasure_, leaving no runtime type information. Deca data types thus correspond almost exactly to the LLVM data types they result in.

# Details #

The hierarchy of integer and floating-point data types in Deca compile directly down to LLVM numerical data types corresponding to their width in bits. Enumeration types are treated as a special case of sum types, compiling down to nothing more than the smallest LLVM integer type required to contain their variant case-tag; booleans are treated as a special case of enumeration types and compile to i1 (a one-bit integer). Deca tuple/record types compile directly down to LLVM structure types, and basic arrow types compile directly to LLVM function types. The “special” work of representing Deca data-types takes place in sum and pointer types.

Deca has two different kinds of pointer types: scoped pointers and reference pointers. Scoped pointers come with scope/escape-analysis information attached, and thus allow writing to their referents as though they were variables. The subtyping rule for scoped pointers is that their target types must be equivalent (invariant), and the scope of the “smaller” pointer type must be smaller than that of the “larger” pointer type. Scoped pointers thus correspond to mutable references as specified in ML and in Pierce's textbook[Pierce2003](Pierce2003.md). Reference pointers, on the other hand, do not allow writing any value larger in size than the immediate target type to their referent. Thus, reference pointers allow covariance of their target types provided those types are tagged (ie: sum types). Thanks to this distinction, Deca can provide unboxed pointer types.

Note that _all_ Deca pointers differ in two important ways from C/C++-style pointers: they do not allow pointer arithmetic, and they are not nullable. Programmers wishing to convey a nullable pointer in Deca code should use an option type, and programmers wishing to refer to dynamic arrays can make use of a language-provided dynamic array type.