Deca maps an object-oriented syntax for the creation of class types down onto its internal sum types. A class declaration creates two internal entities: a single variant case corresponding to the declared class (complete with a variant-style constructor function) and an “open” (able to add cases after its creation) sum type initially containing only that one case. When one class declaration extends another, the variant case for the new declaration has the member variables of its superclass prepended to its own and is added to the open sum of all its superclasses. This maps class hierarchies onto Deca's sum types and their subtyping relation. Constructors are specified with a Scala-like syntax of passing expression parameters to the “class” itself, which are then usable in the initializer expressions of member-variable definitions.

Access to member variables of class instances need not require a variant case-match in Deca due to the calculation of _minimal records_ for sum types. The record portions of every variant case in a sum type are examined to find the set of members common to all of them. This proceeds by comparing variant members at equivalent positions (Deca's records are ordered) in each record for name and type equality. This yields a list specifying in which positions all cases of the variant have the same contents and in which positions they do not. The sublist stretching from the first position to the first difference, should it exist, is taken -- the minimal record of that sum type. Since members of the minimal record exist with the same positions in all cases of the sum type, they can be accessed by their position given any value of the sum type. Minimal records thus correspond to the super-classes found in object-oriented languages.

Deca's reference pointers thus provide the variance capabilities found in Java's object references: access to member variables and covariance[Java2005](Java2005.md). A function which is passed a reference pointer whose target type is a sum-type can receive any a pointer to any case of that sum type, including the ones created through apparent subclassing. The fields in the minimal record of that sum type can be accessed directly via dereferencing, since (being part of the minimal record) they are guaranteed to appear in any actual instance of the type.